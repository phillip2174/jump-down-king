{
  "version": 3,
  "sources": ["../../src/common.ts", "../../src/legacy.ts", "../../src/new.ts", "../../src/LazyGetter.ts"],
  "sourcesContent": ["import {ResultSelectorFn} from './LazyGetter';\n\n/** @internal */\nexport function defaultFilter(): boolean {\n  return true;\n}\n\n/** @internal */\nexport function validateAndExtractMethodFromDescriptor(desc: PropertyDescriptor): Function {\n  const originalMethod = <Function>desc.get;\n\n  if (!originalMethod) {\n    throw new Error('@LazyGetter can only decorate getters!');\n  } else if (!desc.configurable) {\n    throw new Error('@LazyGetter target must be configurable');\n  }\n\n  return originalMethod;\n}\n\n/** @internal */\nexport function getterCommon(//tslint:disable-line:parameters-max-number\n  target: any,\n  key: PropertyKey,\n  isStatic: boolean,\n  enumerable: boolean,\n  originalMethod: Function,\n  thisArg: any,\n  args: IArguments,\n  setProto: boolean,\n  makeNonConfigurable: boolean,\n  resultSelector: ResultSelectorFn\n): any {\n  const value = originalMethod.apply(thisArg, <any>args);\n\n  if (resultSelector(value)) {\n    const newDescriptor: PropertyDescriptor = {\n      configurable: !makeNonConfigurable,\n      enumerable,\n      value\n    };\n\n    if (isStatic || setProto) {\n      Object.defineProperty(target, key, newDescriptor);\n    }\n\n    if (!isStatic) {\n      Object.defineProperty(thisArg, key, newDescriptor);\n    }\n  }\n\n  return value;\n}\n", "import {getterCommon, validateAndExtractMethodFromDescriptor} from './common';\nimport {ResultSelectorFn} from './ResultSelectorFn';\n\n/** @internal */\nexport function decorateLegacy(\n  target: any,\n  key: PropertyKey,\n  descriptor: PropertyDescriptor,\n  setProto: boolean,\n  makeNonConfigurable: boolean,\n  //tslint:enable:bool-param-default\n  resultSelector: ResultSelectorFn\n): PropertyDescriptor {\n  /* istanbul ignore if */\n  if (!descriptor) {\n    descriptor = <any>Object.getOwnPropertyDescriptor(target, key);\n    if (!descriptor) {\n      const e = new Error('@LazyGetter is unable to determine the property descriptor');\n      (<any>e).$target = target;\n      (<any>e).$key = key;\n      throw e;\n    }\n  }\n\n  const originalMethod = validateAndExtractMethodFromDescriptor(descriptor);\n\n  return Object.assign({}, descriptor, {\n    get: function (this: any): any {\n      return getterCommon(\n        target,\n        key,\n        Object.getPrototypeOf(target) === Function.prototype,\n        !!descriptor.enumerable,\n        originalMethod,\n        this,\n        arguments,\n        setProto,\n        makeNonConfigurable,\n        resultSelector\n      );\n    }\n  });\n}\n", "import {getterCommon, validateAndExtractMethodFromDescriptor} from './common';\nimport {NewDescriptor} from './NewDescriptor';\nimport {ResultSelectorFn} from './ResultSelectorFn';\n\n/** @internal */\nexport function decorateNew(\n  inp: NewDescriptor,\n  setProto: boolean,\n  makeNonConfigurable: boolean,\n  resultSelector: ResultSelectorFn\n): NewDescriptor {\n  const out: NewDescriptor = Object.assign({}, inp);\n  if (out.descriptor) {\n    out.descriptor = Object.assign({}, out.descriptor);\n  }\n  const actualDesc: PropertyDescriptor = <any>(out.descriptor || /* istanbul ignore next */ out);\n\n  const originalMethod = validateAndExtractMethodFromDescriptor(actualDesc);\n  const isStatic = inp.placement === 'static';\n\n  actualDesc.get = function (this: any): any {\n    return getterCommon(\n      isStatic ? this : Object.getPrototypeOf(this),\n      out.key,\n      isStatic,\n      !!actualDesc.enumerable,\n      originalMethod,\n      this,\n      arguments,\n      setProto,\n      makeNonConfigurable,\n      resultSelector\n    );\n  };\n\n  return out;\n}\n", "import {defaultFilter} from './common';\nimport {decorateLegacy} from './legacy';\nimport {decorateNew} from './new';\nimport {NewDescriptor} from './NewDescriptor';\nimport {ResettableDescriptor} from './ResettableDescriptor';\nimport {ResultSelectorFn} from './ResultSelectorFn';\n\ntype DecoratorReturn = PropertyDescriptor | NewDescriptor;\n\n/**\n * Evaluate the getter function and cache the result\n * @param [setProto=false] Set the value on the class prototype as well. Only applies to non-static getters.\n * @param [makeNonConfigurable=false] Set to true to make the resolved property non-configurable\n * @param [resultSelector] A filter function that must return true for the value to cached\n * @return A decorator function\n */\nfunction LazyGetter(\n  setProto = false,\n  makeNonConfigurable = false,\n  resultSelector: ResultSelectorFn = defaultFilter\n): MethodDecorator & ResettableDescriptor {\n  let desc: PropertyDescriptor;\n  let prop: PropertyKey;\n  let args: IArguments = <any>null;\n  let isLegacy: boolean;\n\n  function decorator(targetOrDesc: any, key: PropertyKey, descriptor: PropertyDescriptor): DecoratorReturn {\n    args = arguments;\n    if (key === undefined) {\n      if (typeof desc === 'undefined') {\n        isLegacy = false;\n        prop = (<NewDescriptor>targetOrDesc).key;\n        desc = Object.assign(\n          {},\n          (<NewDescriptor>targetOrDesc).descriptor || /* istanbul ignore next */ targetOrDesc\n        );\n      }\n\n      return decorateNew(targetOrDesc, setProto, makeNonConfigurable, resultSelector);\n    } else {\n      if (typeof desc === 'undefined') {\n        isLegacy = true;\n        prop = key;\n        desc = Object.assign(\n          {},\n          descriptor || /* istanbul ignore next */ Object.getOwnPropertyDescriptor(targetOrDesc, key)\n        );\n      }\n\n      return decorateLegacy(targetOrDesc, key, descriptor, setProto, makeNonConfigurable, resultSelector);\n    }\n  }\n\n  decorator.reset = setProto ? thrower : (on: any): void => {\n    if (!on) {\n      throw new Error('Unable to restore descriptor on an undefined target');\n    }\n    if (!desc) {\n      throw new Error('Unable to restore descriptor. Did you remember to apply your decorator to a method?');\n    }\n    // Restore descriptor to its original state\n    Object.defineProperty(on, prop, desc);\n    const ret: any = decorator.apply(null, <any>args);\n    Object.defineProperty(on, prop, isLegacy ? ret : (ret.descriptor || ret));\n  };\n\n  return decorator;\n}\n\nfunction thrower(): never {\n  throw new Error('This decoration modifies the class prototype and cannot be reset.');\n}\n\nexport {ResultSelectorFn, LazyGetter};\n"],
  "mappings": "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",
  "names": []
}
